"""
Base Strategy Class
Provides the foundation for all trading strategies
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime, timezone
from enum import Enum
from typing import Dict, List, Optional, Any, Union
import pandas as pd
import numpy as np

from ...utils.logging_config import get_combined_logger, log_operation
from ...utils.database_logging import get_trading_logger, get_performance_logger

logger = get_combined_logger("mltrading.strategies.base")
trading_logger = get_trading_logger()
performance_logger = get_performance_logger()


class StrategyState(Enum):
    """Strategy execution states"""
    CREATED = "created"
    INITIALIZED = "initialized"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"


class SignalType(Enum):
    """Types of trading signals"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


@dataclass


class StrategySignal:
    """Trading signal generated by a strategy"""
    symbol: str
    signal_type: SignalType
    strength: float  # 0.0 to 1.0, confidence level
    timestamp: datetime
    price: Optional[float] = None
    quantity: Optional[int] = None
    metadata: Optional[Dict[str, Any]] = None


    def __post_init__(self):
        if self.timestamp.tzinfo is None:
            self.timestamp = self.timestamp.replace(tzinfo=timezone.utc)

        # Validate strength
        if not 0.0 <= self.strength <= 1.0:
            raise ValueError(f"Signal strength must be between 0.0 and 1.0, got {self.strength}")


@dataclass


class StrategyPosition:
    """Represents a position managed by a strategy"""
    symbol: str
    quantity: int  # Positive for long, negative for short
    entry_price: float
    entry_time: datetime
    current_price: Optional[float] = None
    unrealized_pnl: Optional[float] = None
    metadata: Optional[Dict[str, Any]] = None


@dataclass


class StrategyPerformance:
    """Strategy performance metrics"""
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_pnl: float = 0.0
    win_rate: float = 0.0
    avg_win: float = 0.0
    avg_loss: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies

    This class provides the framework for implementing trading strategies
    with common functionality like signal generation, risk management,
    and performance tracking.
    """


    def __init__(self,
                 name: str,
                 symbols: List[str],
                 parameters: Dict[str, Any] = None,
                 risk_params: Dict[str, Any] = None):
        """
        Initialize the strategy

        Args:
            name: Strategy name
            symbols: List of symbols to trade
            parameters: Strategy-specific parameters
            risk_params: Risk management parameters
        """
        self.name = name
        self.symbols = symbols
        self.parameters = parameters or {}
        self.risk_params = risk_params or {}

        # Strategy state
        self.state = StrategyState.CREATED
        self.positions: Dict[str, StrategyPosition] = {}
        self.signals_history: List[StrategySignal] = []
        self.performance = StrategyPerformance()

        # Data storage
        self.market_data: Dict[str, pd.DataFrame] = {}
        self.indicators: Dict[str, Dict[str, Any]] = {}

        # Configuration
        self.max_position_size = self.risk_params.get('max_position_size', 1000)
        self.max_drawdown = self.risk_params.get('max_drawdown', 0.05)  # 5%
        self.stop_loss_pct = self.risk_params.get('stop_loss_pct', 0.02)  # 2%
        self.take_profit_pct = self.risk_params.get('take_profit_pct', 0.04)  # 4%

        # Logging
        self.logger = get_combined_logger(f"mltrading.strategies.{name.lower()}")

        logger.info(f"Strategy '{name}' created with symbols: {symbols}")

    @abstractmethod


    def generate_signals(self, market_data: Dict[str, pd.DataFrame]) -> List[StrategySignal]:
        """
        Generate trading signals based on market data

        Args:
            market_data: Dictionary of symbol -> DataFrame with OHLCV data

        Returns:
            List of trading signals
        """
        pass

    @abstractmethod


    def calculate_position_size(self, signal: StrategySignal,
                              available_capital: float) -> int:
        """
        Calculate position size for a signal

        Args:
            signal: Trading signal
            available_capital: Available capital for trading

        Returns:
            Position size (number of shares)
        """
        pass


    def initialize(self, **kwargs):
        """
        Initialize the strategy with any required setup
        Can be overridden by concrete strategies
        """
        try:
            with log_operation(f"initialize_strategy_{self.name}", self.logger):
                self.state = StrategyState.INITIALIZED
                self.performance.start_time = datetime.now(timezone.utc)

                # Log strategy initialization
                trading_logger.log_trading_event(
                    event_type="strategy_initialized",
                    strategy=self.name,
                    symbols=",".join(self.symbols),
                    parameters=self.parameters,
                    risk_params=self.risk_params
                )

                self.logger.info(f"Strategy '{self.name}' initialized successfully")

        except Exception as e:
            self.state = StrategyState.ERROR
            self.logger.error(f"Failed to initialize strategy '{self.name}': {e}")
            raise


    def start(self):
        """Start the strategy execution"""
        if self.state != StrategyState.INITIALIZED:
            raise ValueError(f"Strategy must be initialized before starting. Current state: {self.state}")

        self.state = StrategyState.RUNNING
        self.logger.info(f"Strategy '{self.name}' started")

        trading_logger.log_trading_event(
            event_type="strategy_started",
            strategy=self.name
        )


    def pause(self):
        """Pause the strategy execution"""
        if self.state == StrategyState.RUNNING:
            self.state = StrategyState.PAUSED
            self.logger.info(f"Strategy '{self.name}' paused")


    def stop(self):
        """Stop the strategy execution"""
        self.state = StrategyState.STOPPED
        self.performance.end_time = datetime.now(timezone.utc)
        self.logger.info(f"Strategy '{self.name}' stopped")

        trading_logger.log_trading_event(
            event_type="strategy_stopped",
            strategy=self.name,
            performance=self._get_performance_summary()
        )


    def update_market_data(self, symbol: str, data: pd.DataFrame):
        """
        Update market data for a symbol

        Args:
            symbol: Trading symbol
            data: OHLCV data
        """
        self.market_data[symbol] = data
        self._update_indicators(symbol, data)


    def _update_indicators(self, symbol: str, data: pd.DataFrame):
        """
        Update technical indicators for a symbol
        Override this method to calculate custom indicators

        Args:
            symbol: Trading symbol
            data: OHLCV data
        """
        if symbol not in self.indicators:
            self.indicators[symbol] = {}

        # Basic indicators that most strategies will use
        if len(data) >= 20:
            # Simple Moving Averages
            self.indicators[symbol]['sma_10'] = data['close'].rolling(10).mean()
            self.indicators[symbol]['sma_20'] = data['close'].rolling(20).mean()

            # RSI
            self.indicators[symbol]['rsi'] = self._calculate_rsi(data['close'])

            # Bollinger Bands
            bb_upper, bb_middle, bb_lower = self._calculate_bollinger_bands(data['close'])
            self.indicators[symbol]['bb_upper'] = bb_upper
            self.indicators[symbol]['bb_middle'] = bb_middle
            self.indicators[symbol]['bb_lower'] = bb_lower


    def _calculate_rsi(self, prices: pd.Series, period: int = 14) -> pd.Series:
        """Calculate RSI indicator"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi


    def _calculate_bollinger_bands(self, prices: pd.Series, period: int = 20, std_dev: int = 2):
        """Calculate Bollinger Bands"""
        sma = prices.rolling(period).mean()
        std = prices.rolling(period).std()
        upper = sma + (std * std_dev)
        lower = sma - (std * std_dev)
        return upper, sma, lower


    def process_signal(self, signal: StrategySignal, available_capital: float) -> Optional[Dict[str, Any]]:
        """
        Process a trading signal and generate order instructions

        Args:
            signal: Trading signal to process
            available_capital: Available capital for trading

        Returns:
            Order instructions or None if signal is rejected
        """
        try:
            with log_operation(f"process_signal_{signal.symbol}", self.logger):
                # Validate signal
                if not self._validate_signal(signal):
                    return None

                # Calculate position size
                position_size = self.calculate_position_size(signal, available_capital)
                if position_size == 0:
                    self.logger.info(f"Position size is 0 for signal {signal.symbol} {signal.signal_type}")
                    return None

                # Apply risk management
                if not self._check_risk_limits(signal, position_size):
                    return None

                # Create order instructions
                order_instructions = {
                    'symbol': signal.symbol,
                    'side': signal.signal_type.value,
                    'quantity': abs(position_size),
                    'order_type': 'market',  # Can be made configurable
                    'time_in_force': 'day',
                    'signal_strength': signal.strength,
                    'signal_metadata': signal.metadata,
                    'strategy': self.name
                }

                # Log signal processing
                trading_logger.log_trading_event(
                    event_type="signal_processed",
                    symbol=signal.symbol,
                    side=signal.signal_type.value,
                    quantity=position_size,
                    strategy=self.name,
                    signal_strength=signal.strength
                )

                # Store signal in history
                self.signals_history.append(signal)

                return order_instructions

        except Exception as e:
            self.logger.error(f"Error processing signal for {signal.symbol}: {e}")
            return None


    def _validate_signal(self, signal: StrategySignal) -> bool:
        """Validate a trading signal"""
        # Check if symbol is in our trading list
        if signal.symbol not in self.symbols:
            self.logger.warning(f"Signal for {signal.symbol} not in strategy symbols")
            return False

        # Check signal strength threshold
        min_strength = self.parameters.get('min_signal_strength', 0.5)
        if signal.strength < min_strength:
            self.logger.debug(f"Signal strength {signal.strength} below threshold {min_strength}")
            return False

        return True


    def _check_risk_limits(self, signal: StrategySignal, position_size: int) -> bool:
        """Check if signal passes risk management rules"""
        # Check maximum position size
        if abs(position_size) > self.max_position_size:
            self.logger.warning(f"Position size {position_size} exceeds max {self.max_position_size}")
            return False

        # Check if we already have a position in this symbol
        existing_position = self.positions.get(signal.symbol)
        if existing_position and signal.signal_type in [SignalType.BUY, SignalType.SELL]:
            # Don't add to existing position (can be changed based on strategy)
            self.logger.info(f"Already have position in {signal.symbol}, skipping signal")
            return False

        return True


    def update_position(self, symbol: str, fill_data: Dict[str, Any]):
        """
        Update position after an order fill

        Args:
            symbol: Trading symbol
            fill_data: Fill information from broker
        """
        try:
            quantity = fill_data.get('quantity', 0)
            price = fill_data.get('price', 0.0)
            side = fill_data.get('side', '')

            if side == 'sell':
                quantity = -quantity

            if symbol in self.positions:
                # Update existing position
                position = self.positions[symbol]
                # For simplicity, replace position (can be enhanced for partial fills)
                position.quantity = quantity
                position.entry_price = price
                position.entry_time = datetime.now(timezone.utc)
            else:
                # Create new position
                self.positions[symbol] = StrategyPosition(
                    symbol=symbol,
                    quantity=quantity,
                    entry_price=price,
                    entry_time=datetime.now(timezone.utc)
                )

            # Log position update
            trading_logger.log_trading_event(
                event_type="position_updated",
                symbol=symbol,
                side=side,
                quantity=abs(quantity),
                price=price,
                strategy=self.name
            )

            self.logger.info(f"Position updated for {symbol}: {quantity} shares at ${price}")

        except Exception as e:
            self.logger.error(f"Error updating position for {symbol}: {e}")


    def close_position(self, symbol: str) -> Optional[StrategySignal]:
        """
        Generate signal to close a position

        Args:
            symbol: Symbol to close position for

        Returns:
            Close signal or None
        """
        if symbol not in self.positions:
            return None

        position = self.positions[symbol]
        signal_type = SignalType.CLOSE_SHORT if position.quantity < 0 else SignalType.CLOSE_LONG

        signal = StrategySignal(
            symbol=symbol,
            signal_type=signal_type,
            strength=1.0,  # High confidence for position closing
            timestamp=datetime.now(timezone.utc),
            quantity=abs(position.quantity),
            metadata={'reason': 'strategy_close_position'}
        )

        return signal


    def _get_performance_summary(self) -> Dict[str, Any]:
        """Get current performance summary"""
        return {
            'total_trades': self.performance.total_trades,
            'winning_trades': self.performance.winning_trades,
            'losing_trades': self.performance.losing_trades,
            'total_pnl': self.performance.total_pnl,
            'win_rate': self.performance.win_rate,
            'max_drawdown': self.performance.max_drawdown
        }


    def get_status(self) -> Dict[str, Any]:
        """Get current strategy status"""
        return {
            'name': self.name,
            'state': self.state.value,
            'symbols': self.symbols,
            'positions': len(self.positions),
            'signals_generated': len(self.signals_history),
            'performance': self._get_performance_summary(),
            'parameters': self.parameters,
            'risk_params': self.risk_params
        }

